<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TetrisMoon — Juego Personalizable</title>
  <style>
    /* -------------------------
       VARIABLES (fáciles de cambiar)
       -------------------------*/
    :root{
      --page-bg: linear-gradient(180deg,#0b1b3a 0%, #071827 100%); /* fondo de la página */
      --game-area-bg: linear-gradient(180deg,#071021 0%, #0b1630 100%); /* fondo del area del juego */
      --accent-1: #ff4d6d; /* color llamativo */
      --accent-2: #ffd24d;
      --accent-3: #6bffef;
      --grid-border: rgba(255,255,255,0.08);
      --panel-bg: rgba(255,255,255,0.04);
      --text: #f0f6ff;
      --muted: rgba(240,246,255,0.7);
      --block-size: 28px; /* tamaño base del bloque, se ajusta según pantalla */
    }

    /* -------------------------
       Reset + Layout
       -------------------------*/
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: Inter, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;
      background: var(--page-bg);
      color:var(--text);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      display:flex;
      min-height:100vh;
      flex-direction:column;
    }

    /* Contenedor principal flexible: juego + promo + panel */
    .wrap{
      max-width:1200px;
      margin:20px auto 120px; /* espacio bottom para footer fijo */
      padding:16px;
      display:grid;
      grid-template-columns: 1fr 300px; /* juego | promo/panel */
      gap:18px;
      align-items:start;
    }

    /* On small screens stack vertical */
    @media (max-width:900px){
      .wrap{grid-template-columns:1fr; margin:14px;}
      .promo{order:-1}
    }

    /* Área del juego */
    .game-card{
      background:var(--game-area-bg);
      border-radius:14px;
      padding:14px;
      box-shadow: 0 6px 30px rgba(0,0,0,0.45);
      display:flex;
      gap:14px;
      align-items:flex-start;
      border:1px solid var(--grid-border);
    }

    /* Canvas y side panel dentro del card */
    .board-wrap{display:flex;flex-direction:column;gap:12px;align-items:center;width:100%}
    .canvas-outer{
      background:transparent; /* se ve el fondo del .game-card */
      padding:8px;
      border-radius:10px;
      display:flex;justify-content:center;align-items:center;
      width:100%;
    }

    /* Canvas se redimensiona con el contenedor: usamos CSS para que sea responsive */
    canvas#gameCanvas{background:transparent; display:block; max-width:100%; height:auto; border-radius:8px}

    /* panel derecho con score, controles y parámetros */
    .panel{
      width:260px;
      background:var(--panel-bg);
      border-radius:12px;
      padding:12px;
      display:flex;flex-direction:column;gap:10px;
      border:1px solid rgba(255,255,255,0.03);
    }

    .panel h3{margin:0 0 6px 0;font-size:16px}
    .stat{font-weight:700;font-size:20px}
    .muted{color:var(--muted);font-size:13px}

    /* controles táctiles (visible en móvil) */
    .touch-controls{display:none;gap:8px}
    @media (max-width:900px){.touch-controls{display:flex;justify-content:center}}

    .btn{background:linear-gradient(180deg,rgba(255,255,255,0.06), rgba(255,255,255,0.02));padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.06);cursor:pointer}
    .btn:active{transform:translateY(1px)}

    .big-btn{padding:14px;border-radius:12px;font-weight:700}

    /* Promo image area (externa al juego) */
    .promo{
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      padding:12px;border-radius:12px;border:1px solid rgba(255,255,255,0.03);
      display:flex;flex-direction:column;align-items:center;gap:10px;height:fit-content
    }
    .promo img{width:100%;height:auto;border-radius:10px;object-fit:cover}

    /* hidden phrases - en DOM pero fuera de vista del jugador */
    .hidden-phrases{position:absolute;left:-9999px;top:auto;width:1px;height:1px;overflow:hidden}

    /* footer fijo abajo con links */
    footer{
      position:fixed;left:0;right:0;bottom:0;background:linear-gradient(180deg, rgba(0,0,0,0.45), rgba(0,0,0,0.6));backdrop-filter: blur(6px);
      color:var(--muted);padding:12px 18px;display:flex;justify-content:center;align-items:center;gap:12px;border-top:1px solid rgba(255,255,255,0.03)
    }
    footer .links{display:flex;gap:12px;flex-wrap:wrap}
    footer a{color:var(--muted);text-decoration:none;font-weight:600}

    /* instrucciones dentro de la página (visibles) */
    .instructions{font-size:13px;line-height:1.35;color:var(--muted);}

    /* estéticos blocks brillantes */
    .tetris-block{
      border-radius:6px; box-shadow: 0 3px 0 rgba(0,0,0,0.25) inset, 0 6px 18px rgba(0,0,0,0.35);
    }

    /* small helpers */
    .row{display:flex;gap:8px;align-items:center}
    input[type="color"], input[type="text"], input[type="number"]{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:var(--text)}
    label{font-size:12px;color:var(--muted)}
    .small{font-size:12px}

    /* developer controls (hidden by default) */
    .dev-controls{position:fixed;right:12px;bottom:72px;background:rgba(0,0,0,0.45);padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);display:flex;gap:8px;align-items:center}
    .dev-controls.hidden{display:none}
  </style>
  <!-- Bloque para fijar pantalla y evitar desplazamientos en móvil -->
  <script>
  // -------------------------------
  // TETRIS CORE (simple y funcional) con rotaciones mejoradas
  // -------------------------------
  (function(){
    'use strict';

    // ----------------------
    // Developer flags
    // ----------------------
    const DEV = false; // <<-- cambiar a true manualmente cuando seas el desarrollador

    if(DEV){
      const devEl = document.getElementById('devControls');
      if(devEl) { devEl.classList.remove('hidden'); devEl.setAttribute('aria-hidden','false'); }
    }

    const COLS = 10;
    const ROWS = 20;

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    function resizeCanvas(){
      const containerWidth = Math.min(480, Math.floor(window.innerWidth * 0.92));
      const block = Math.max(18, Math.floor(containerWidth / COLS));
      const width = block * COLS;
      const height = block * ROWS;
      canvas.width = width;
      canvas.height = height;
      document.documentElement.style.setProperty('--block-size', block + 'px');
      if(typeof board !== 'undefined' && board) draw();
    }
    window.addEventListener('resize', resizeCanvas);

    // Definimos las piezas como matrices base (estado 0). Para permitir rotaciones con estados
    const SHAPES = [
      [[1,1,1,1]], // I
      [[1,1],[1,1]], // O
      [[0,1,0],[1,1,1]], // T
      [[1,1,0],[0,1,1]], // Z
      [[0,1,1],[1,1,0]], // S
      [[1,0,0],[1,1,1]], // L
      [[0,0,1],[1,1,1]]  // J
    ];

    const COLORS = ['#00e1ff','#ffd200','#ff4d6d','#6bffef','#8b5cff','#ff8a00','#3eff7f'];

    // Juego
    let board;
    let current = null; // { shape, id, x, y, rot }
    let nextPieces = [];
    let score = 0, lines = 0, level = 1;
    let dropCounter = 0, dropInterval = 1000;
    let lastTime = 0;
    let playing = false;

    function createMatrix(w,h){
      const m = [];
      for(let y=0;y<h;y++) m.push(new Array(w).fill(0));
      return m;
    }

    function copyMatrix(m){ return m.map(row=>row.slice()); }

    // rotate matrix clockwise (dir=1) or counterclockwise (dir=-1)
    function rotateMatrix(matrix, dir){
      // Create a transposed copy then reverse rows or columns
      const sizeY = matrix.length;
      const sizeX = matrix[0].length;
      const res = Array.from({length: sizeX}, ()=>Array(sizeY).fill(0));
      for(let y=0;y<sizeY;y++) for(let x=0;x<sizeX;x++) res[x][y] = matrix[y][x];
      if(dir>0) res.forEach(row=>row.reverse()); else res.reverse();
      return res;
    }

    // improved wall kicks: try a set of offsets after rotating
    const KICK_OFFSETS = [
      {x:0,y:0}, {x:1,y:0}, {x:-1,y:0}, {x:2,y:0}, {x:-2,y:0}, {x:0,y:-1}, {x:0,y:1}
    ];

    // For I-piece we can try a slightly larger set (simple heuristic)
    const I_KICK_OFFSETS = [
      {x:0,y:0},{x:1,y:0},{x:-1,y:0},{x:2,y:0},{x:-2,y:0},{x:0,y:-1},{x:0,y:1},{x:3,y:0},{x:-3,y:0}
    ];

    function newPiece(){
      if(nextPieces.length < 7) fillBag();
      const id = nextPieces.shift();
      return { shape: copyMatrix(SHAPES[id]), id, x: Math.floor((COLS - SHAPES[id][0].length)/2), y: -1, rot:0 };
    }

    function fillBag(){
      const bag = [0,1,2,3,4,5,6];
      for(let i=bag.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [bag[i],bag[j]]=[bag[j],bag[i]];
      }
      nextPieces = nextPieces.concat(bag);
    }

    function collide(boardRef, piece){
      const m = piece.shape;
      for(let y=0;y<m.length;y++){
        for(let x=0;x<m[y].length;x++){
          if(m[y][x]){
            const bx = piece.x + x;
            const by = piece.y + y;
            if(by>=ROWS || bx<0 || bx>=COLS) return true;
            if(by>=0 && boardRef[by][bx]) return true;
          }
        }
      }
      return false;
    }

    function merge(boardRef, piece){
      const m = piece.shape;
      for(let y=0;y<m.length;y++){
        for(let x=0;x<m[y].length;x++){
          if(m[y][x] && piece.y+y>=0) boardRef[piece.y+y][piece.x+x] = piece.id+1;
        }
      }
    }

    function lockPiece(){
      if(!current) return;
      merge(board,current);
      // clear lines
      let rowCount=0;
      outer: for(let y=ROWS-1;y>=0;y--){
        for(let x=0;x<COLS;x++) if(!board[y][x]) continue outer;
        const row = board.splice(y,1)[0].fill(0);
        board.unshift(row);
        y++; rowCount++;
      }
      if(rowCount>0){
        lines += rowCount;
        score += (rowCount*100) * rowCount;
        level = Math.floor(lines/10)+1;
        dropInterval = Math.max(100, 1000 - (level-1)*80);
        document.getElementById('score').textContent = score;
        document.getElementById('lines').textContent = lines;
        document.getElementById('level').textContent = level;
      }
    }

    function spawn(){
      current = newPiece();
      if(collide(board,current)){
        // game over -> reset board
        playing=false;
        document.getElementById('startBtn').textContent = 'Iniciar / Pausa';
        for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++) board[y][x]=0;
        score=0;lines=0;level=1;document.getElementById('score').textContent=0;document.getElementById('lines').textContent=0;document.getElementById('level').textContent=1;
      }
    }

    function hardDrop(){
      if(!current) return;
      while(!collide(board,{...current, y: current.y+1})) current.y++;
      lockPiece(); spawn();
    }

    // Nueva función: intenta rotar con wall-kicks mejoradas
    function attemptRotate(dir){
      if(!current) return;
      // rotate a copy first
      const rotated = rotateMatrix(current.shape, dir);
      const offsets = (current.id === 0) ? I_KICK_OFFSETS : KICK_OFFSETS;
      for(let i=0;i<offsets.length;i++){
        const ox = offsets[i].x;
        const oy = offsets[i].y;
        const test = { ...current, shape:rotated, x: current.x + ox, y: current.y + oy };
        if(!collide(board, test)){
          current.shape = rotated;
          current.x = test.x; current.y = test.y;
          current.rot = (current.rot + (dir>0 ? 1 : 3)) % 4;
          return true;
        }
      }
      return false;
    }

    // movimiento y rotación del jugador
    function playerRotate(dir){
      attemptRotate(dir);
    }
    function playerRotateCCW(){ attemptRotate(-1); }

    function playerDrop(){
      if(!current) return;
      current.y++;
      if(collide(board,current)){
        current.y--;
        lockPiece();
        spawn();
      }
      dropCounter = 0;
    }

    function playerMove(dir){
      if(!current) return;
      current.x += dir;
      if(collide(board,current)) current.x -= dir;
    }

    // Dibujo
    function drawCell(x,y,val){
      const bw = canvas.width/COLS; const bh = canvas.height/ROWS;
      const px = x*bw; const py = y*bh;
      if(val){
        const c = COLORS[val-1] || '#fff';
        ctx.fillStyle = c;
        roundRect(ctx,px+1,py+1,bw-2,bh-2,Math.max(2,bw*0.08));
        ctx.fill();
        ctx.fillStyle = 'rgba(255,255,255,0.12)';
        ctx.fillRect(px+2,py+2,Math.min(10,bw*0.25),Math.min(12,bh*0.25));
      } else {
        ctx.fillStyle = 'rgba(255,255,255,0.02)';
        ctx.fillRect(px+0.5,py+0.5,bw-1,bh-1);
      }
    }
    function roundRect(ctx,x,y,w,h,r){
      ctx.beginPath();
      ctx.moveTo(x+r,y);
      ctx.arcTo(x+w,y,x+w,y+h,r);
      ctx.arcTo(x+w,y+h,x,y+h,r);
      ctx.arcTo(x,y+h,x,y,r);
      ctx.arcTo(x,y,x+w,y,r);
      ctx.closePath();
    }

    function draw(){
      if(typeof board === 'undefined' || !board) return;
      ctx.clearRect(0,0,canvas.width,canvas.height);
      for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++) drawCell(x,y,board[y][x]);
      if(current){
        const m = current.shape;
        for(let y=0;y<m.length;y++){
          for(let x=0;x<m[y].length;x++){
            if(m[y][x]) drawCell(current.x+x,current.y+y,current.id+1);
          }
        }
      }
    }

    function update(time=0){
      const dt = time - lastTime; lastTime = time;
      dropCounter += dt;
      if(playing && dropCounter > dropInterval){
        if(current) current.y++;
        if(current && collide(board,current)){
          current.y--;
          lockPiece(); spawn();
        }
        dropCounter = 0;
      }
      draw();
      requestAnimationFrame(update);
    }

    // Input
    document.addEventListener('keydown', e=>{
      if(e.code==='ArrowLeft') playerMove(-1);
      if(e.code==='ArrowRight') playerMove(1);
      if(e.code==='ArrowUp') playerRotate(1);
      if(e.code==='KeyZ') playerRotateCCW();
      if(e.code==='ArrowDown') playerDrop();
      if(e.code==='Space') { hardDrop(); }
    });

    // touch buttons
    const leftBtn = document.getElementById('leftBtn');
    const rightBtn = document.getElementById('rightBtn');
    const rotateBtn = document.getElementById('rotateBtn');
    const downBtn = document.getElementById('downBtn');
    if(leftBtn) leftBtn.addEventListener('touchstart',()=>playerMove(-1));
    if(rightBtn) rightBtn.addEventListener('touchstart',()=>playerMove(1));
    if(rotateBtn) rotateBtn.addEventListener('touchstart',()=>playerRotate(1));
    if(downBtn) downBtn.addEventListener('touchstart',()=>playerDrop());

    // click buttons
    document.getElementById('startBtn').addEventListener('click',()=>{
      playing = !playing;
      if(playing){
        document.getElementById('startBtn').textContent='Pausa';
        if(!current) { spawn(); }
      } else document.getElementById('startBtn').textContent='Iniciar / Pausa';
    });
    document.getElementById('saveBtn').addEventListener('click',()=>{
      board = createMatrix(COLS,ROWS); nextPieces=[]; current=null; score=0;lines=0;level=1;document.getElementById('score').textContent=0;document.getElementById('lines').textContent=0;document.getElementById('level').textContent=1; playing=false; document.getElementById('startBtn').textContent='Iniciar / Pausa';
    });
    document.getElementById('dropBtn').addEventListener('click',()=>{ hardDrop(); });

    // canvas pointer handling
    let lastTap=0;
    canvas.addEventListener('pointerdown',(ev)=>{
      const rect = canvas.getBoundingClientRect();
      const x = ev.clientX - rect.left;
      const w = rect.width;
      const now = Date.now();
      if(now - lastTap < 250){
        playerRotate(1);
      } else {
        if(x < w*0.4) playerMove(-1);
        else if(x > w*0.6) playerMove(1);
        else playerDrop();
      }
      lastTap = now;
    });

    // estilos y personalizacion
    const pageBgInput = document.getElementById('pageBgInput');
    const gameBgInput = document.getElementById('gameBgInput');
    const promoInput = document.getElementById('promoInput');
    const applyStyle = document.getElementById('applyStyle');
    const resetStyle = document.getElementById('resetStyle');
    const promoImg = document.getElementById('promoImg');

    pageBgInput.value = getComputedStyle(document.documentElement).getPropertyValue('--page-bg').trim();
    gameBgInput.value = getComputedStyle(document.documentElement).getPropertyValue('--game-area-bg').trim();

    applyStyle.addEventListener('click', ()=>{
      const p = pageBgInput.value.trim();
      const g = gameBgInput.value.trim();
      const pm = promoInput.value.trim();
      if(p) document.body.style.background = p; else document.body.style.background = '';
      if(g) document.querySelector('.game-card').style.background = g; else document.querySelector('.game-card').style.background = '';
      if(pm) promoImg.src = pm; else promoImg.src = '';
      resizeCanvas();
    });

    resetStyle.addEventListener('click', ()=>{
      document.body.style.background = '';
      document.querySelector('.game-card').style.background = '';
      promoImg.src = '';
      pageBgInput.value = getComputedStyle(document.documentElement).getPropertyValue('--page-bg').trim();
      gameBgInput.value = getComputedStyle(document.documentElement).getPropertyValue('--game-area-bg').trim();
    });

    document.getElementById('applyColors').addEventListener('click', ()=>{
      const a1 = document.getElementById('accent1').value;
      const a2 = document.getElementById('accent2').value;
      const a3 = document.getElementById('accent3').value;
      document.documentElement.style.setProperty('--accent-1', a1);
      document.documentElement.style.setProperty('--accent-2', a2);
      document.documentElement.style.setProperty('--accent-3', a3);
      COLORS[0]=a3; COLORS[1]=a2; COLORS[2]=a1;
    });

    // inicializacion
    board = createMatrix(COLS, ROWS);
    fillBag(); spawn();
    resizeCanvas();
    update();

    // controles de desarrollador (cuando DEV=true)
    if(DEV){
      const devFsBtn = document.getElementById('devFullscreenBtn');
      const devLockBtn = document.getElementById('devLockOrientBtn');
      if(devFsBtn){
        devFsBtn.addEventListener('click', async ()=>{
          try{ const el = document.documentElement; if(el.requestFullscreen) await el.requestFullscreen(); }
          catch(err){ alert('No se pudo activar fullscreen: '+(err&&err.message?err.message:err)); }
        });
      }
      if(devLockBtn){
        devLockBtn.addEventListener('click', async ()=>{
          try{ if(screen.orientation && screen.orientation.lock) await screen.orientation.lock('portrait'); else alert('Bloqueo no soportado'); }
          catch(err){ alert('No se pudo bloquear la orientación: '+(err&&err.message?err.message:err)); }
        });
      }
    }

  })();
  </script>
</body>
</html>
