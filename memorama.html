<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>BlackMoon Bike — Motocross Noche→Día (20 niveles) — Rebote leve</title>
<style>
  :root{--ui-bg:rgba(0,0,0,0.5)}
  html,body{height:100%;margin:0;font-family:Inter,Arial,Helvetica,sans-serif;background:#000;color:#fff}
  #wrap{display:flex;flex-direction:column;align-items:center;gap:8px;padding:8px}
  canvas{background:transparent;border-radius:8px;box-shadow:0 6px 20px rgba(0,0,0,0.6);max-width:100%}
  #hud{width:100%;max-width:1200px;display:flex;justify-content:space-between;align-items:center;padding:6px;box-sizing:border-box}
  .scoreBox{padding:6px 10px;border-radius:8px;background:var(--ui-bg);font-size:16px}
  .controls{display:flex;gap:8px;align-items:center}
  .control-btn{background:#111;border:none;padding:10px 14px;border-radius:8px;color:#fff;font-size:15px;touch-action:none}
  .control-btn:active{transform:translateY(2px)}
  #footer{color:#bbb;font-size:12px}
  #mobileControls{position:fixed;left:0;right:0;bottom:10px;display:flex;justify-content:center;gap:12px;pointer-events:none}
  .mobileBtn{pointer-events:auto;background:rgba(0,0,0,0.45);color:#fff;border-radius:12px;padding:14px 18px;border:2px solid rgba(255,255,255,0.06);font-size:18px}
  @media(min-width:900px){#mobileControls{display:none}}
  #levelInfo{font-size:14px;color:#ddd}
  .small{font-size:13px;padding:6px 8px}
</style>
</head>
<body>
<div id="wrap">
  <div id="hud">
    <div class="scoreBox" id="score">Puntaje: 0</div>
    <div id="levelInfo" class="scoreBox">Nivel: 1 / 20 — Récord: 0</div>
    <div class="controls">
      <button class="control-btn small" id="btnBack">◀</button>
      <button class="control-btn small" id="btnForward">▶</button>
      <button class="control-btn" id="btnAccel">Acelerar ▲</button>
      <button class="control-btn small" id="btnMute">Mute</button>
      <button class="control-btn small" id="btnPause">Pausa</button>
    </div>
  </div>

  <canvas id="game" width="1200" height="600"></canvas>

  <div id="footer">Grupo BlackMoon — BlackMoon Games</div>
</div>

<div id="mobileControls">
  <button class="mobileBtn" id="mBack">◀</button>
  <button class="mobileBtn" id="mAccel">▲</button>
  <button class="mobileBtn" id="mForward">▶</button>
</div>

<script>
/* =====================================================
   BlackMoon Bike — Juego completo en un archivo
   Actualización: rebote leve + suspensión suave para mantener moto cerca del suelo
   - 20 niveles fijos
   - Sprites configurables (cambia URLs abajo)
   - 4 pistas de fondo (configurables)
   - Efectos de sonido (configurables)
   - Guarda récord en localStorage (key: bm_best_score)
   - Controles: teclado, botones, touch
   ===================================================== */

/* ====================== ZONA DE CUSTOMIZACIÓN ======================
   Sustituye las rutas por tus imágenes y audios.
==================================================================== */
const ASSETS = {
  bikeSprite: 'assets/bike.png',           // <-- CAMBIAR por ruta válida (PNG)
  bgMountainSprite: 'assets/mountains.png',// <-- opcional
  groundTileSprite: '',                    // <-- opcional
  musicTracks: [
    'audio/track1.mp3', // nivel 1-5
    'audio/track2.mp3', // nivel 6-10
    'audio/track3.mp3', // nivel 11-15
    'audio/track4.mp3'  // nivel 16-20
  ],
  sfx: {
    accel: 'audio/accel.mp3',
    bump: 'audio/bump.mp3',
    jump: 'audio/jump.mp3',
    levelUp: 'audio/levelup.mp3'
  }
};
/* ================================================================== */

/* ====================== CONFIGURACIONES ====================== */
const CONFIG = {
  canvasW: 1200,
  canvasH: 600,
  terrainSegW: 40,
  wheelRadius: 14,
  gravity: 0.9,
  accelPower: 0.18,
  maxSpeed: 14,
  dayDistanceFull: 3000,
  levels: 20,
  levelDistance: 1400,
  bumpHeight: 36,
  vadoDepth: 20,
  // Parámetros de suspensión / rebote leve:
  suspensionRestOffset: 36,    // distancia vertical entre suelo y centro de la moto (en px)
  suspensionStiffness: 0.18,   // fuerza que "jala" al bike hacia el rest position (aumenta -> más pegada)
  suspensionDamping: 0.82,     // amortiguación del resorte (0-1) (más cercano a 1 -> menos rebote)
  maxBounceVy: -4.0,           // límite máximo de velocidad vertical ascendente (cuanto "salta")
  bumpBounceFactor: 0.9,       // reduce impulso aplicado por topes
};
/* ================================================================== */

/* =================== Setup canvas & estado =================== */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = CONFIG.canvasW;
canvas.height = CONFIG.canvasH;

let running = true;
let muted = false;
let score = 0;
let totalDistance = 0;
let lastTs = 0;
let keys = {left:false,right:false,up:false};
let mobileTouch = {back:false,forward:false,accel:false};
let currentLevel = 1;
const scoreEl = document.getElementById('score');
const levelInfoEl = document.getElementById('levelInfo');
const BEST_KEY = 'bm_best_score';
let bestScore = parseInt(localStorage.getItem(BEST_KEY) || '0', 10);

/* =================== Cargar imágenes y audios =================== */
const IMGS = {};
const AUD = {music: null, sfx: {}};

function loadImage(key, src){
  return new Promise((res)=>{
    if(!src){ res(null); return; }
    const img = new Image();
    img.src = src;
    img.onload = ()=>{ IMGS[key] = img; res(img) };
    img.onerror = ()=>{ console.warn('No cargó imagen', src); res(null); };
  });
}
function loadAudio(src, loop=false){
  return new Promise((res)=>{
    if(!src){ res(null); return; }
    const a = new Audio(src);
    a.loop = loop;
    a.preload = 'auto';
    a.volume = 0.75;
    a.oncanplaythrough = ()=> res(a);
    a.onerror = ()=> { console.warn('No cargó audio', src); res(null); };
  });
}

/* Load assets */
Promise.all([
  loadImage('bike', ASSETS.bikeSprite),
  loadImage('mount', ASSETS.bgMountainSprite),
  loadImage('ground', ASSETS.groundTileSprite),
  loadAudio(ASSETS.sfx.accel),
  loadAudio(ASSETS.sfx.bump),
  loadAudio(ASSETS.sfx.jump),
  loadAudio(ASSETS.sfx.levelUp)
]).then(results=>{
  IMGS.bike = results[0];
  IMGS.mountain = results[1];
  IMGS.ground = results[2];
  AUD.sfx.accel = results[3];
  AUD.sfx.bump = results[4];
  AUD.sfx.jump = results[5];
  AUD.sfx.levelUp = results[6];
  AUD.music = new Audio();
  AUD.music.loop = true;
  setMusicForLevel(currentLevel);
}).catch(err=>{
  console.warn('Error cargando assets', err);
});

/* =================== Terrenos por nivel (fijos) =================== */
const levelPatterns = [];
function genPattern(typeSequence, repeats){
  const arr = [];
  for(let r=0;r<repeats;r++){
    for(const t of typeSequence) arr.push(t);
  }
  return arr;
}
for(let L=1; L<=CONFIG.levels; L++){
  if(L <= 3) levelPatterns.push(genPattern(['plain','plain','bump','plain'], 40));
  else if(L <= 6) levelPatterns.push(genPattern(['plain','bump','plain','vado'], 42));
  else if(L <= 9) levelPatterns.push(genPattern(['plain','bump','bump','vado','plain'], 40));
  else if(L <= 12) levelPatterns.push(genPattern(['bump','plain','vado','plain','plain','bump'], 36));
  else if(L <= 15) levelPatterns.push(genPattern(['plain','mountain','bump','vado','bump'], 34));
  else if(L <= 18) levelPatterns.push(genPattern(['bump','vado','bump','plain','mountain'], 34));
  else levelPatterns.push(genPattern(['vado','bump','bump','mountain','plain'],36));
}
let terrain = [];
function buildTerrain(){
  terrain = [];
  for(let i=0;i<CONFIG.levels;i++){
    const pat = levelPatterns[i];
    for(let j=0;j<pat.length;j++){
      const base = canvas.height*0.75 + (Math.sin((i*7+j)/6)*28) + (Math.random()*20-10);
      terrain.push({height: base, type: pat[j]});
    }
  }
}
buildTerrain();
function ensureTerrainLength(pxNeeded){ return; }

/* =================== Utilidades terreno =================== */
function heightAt(worldX){
  const idx = Math.floor(worldX / CONFIG.terrainSegW);
  const frac = (worldX % CONFIG.terrainSegW) / CONFIG.terrainSegW;
  const a = terrain[idx] ? terrain[idx].height : canvas.height*0.75;
  const b = terrain[idx+1] ? terrain[idx+1].height : a;
  return a*(1-frac) + b*frac;
}

/* =================== Estado de la moto/jugador =================== */
const bike = {
  x: 220,
  y: canvas.height/2 - 60,
  vx: 0,
  vy: 0,
  angle:0,
  onGround:false
};

/* =================== DAY / NIGHT =================== */
function dayProgress(){ return Math.min(1, totalDistance / CONFIG.dayDistanceFull); }

/* =================== MUSIC control =================== */
function setMusicForLevel(level){
  const idx = Math.floor(((level-1) / CONFIG.levels) * ASSETS.musicTracks.length);
  const track = ASSETS.musicTracks[Math.min(idx, ASSETS.musicTracks.length-1)];
  if(AUD.music){
    AUD.music.pause();
    AUD.music.src = track || '';
    if(!muted) AUD.music.play().catch(()=>{/*autoplay bloqueado hasta interacción*/});
  } else {
    AUD.music = new Audio(track || '');
    AUD.music.loop = true;
    AUD.music.volume = 0.6;
    if(!muted) AUD.music.play().catch(()=>{});
  }
}

/* =================== DIBUJADO =================== */
function drawBackground(){
  const p = dayProgress();
  const nightTop = [6,8,35], dayTop = [135,206,235];
  const top = nightTop.map((v,i)=> Math.round(v*(1-p) + dayTop[i]*p));
  const nightBottom = [10,12,40], dayBottom=[255,255,255];
  const bottom = nightBottom.map((v,i)=> Math.round(v*(1-p) + dayBottom[i]*p));
  const grad = ctx.createLinearGradient(0,0,0,canvas.height);
  grad.addColorStop(0, `rgb(${top.join(',')})`);
  grad.addColorStop(1, `rgb(${bottom.join(',')})`);
  ctx.fillStyle = grad;
  ctx.fillRect(0,0,canvas.width,canvas.height);

  const starAlpha = Math.max(0, 1 - p*1.4);
  if(starAlpha > 0.02){
    ctx.fillStyle = `rgba(255,255,255,${0.6*starAlpha})`;
    for(let i=0;i<60;i++){
      const x = (i*47 % canvas.width) + (Math.sin(totalDistance/100+i)*3);
      const y = (i*73 % (canvas.height*0.5)) + 20;
      ctx.fillRect(x%canvas.width,y, Math.random()*1.8, Math.random()*1.8);
    }
  }

  if(p < 0.95){
    const moonX = canvas.width*0.85;
    const moonY = canvas.height*0.22;
    const moonRadius = 36;
    ctx.beginPath();
    ctx.fillStyle = `rgba(245,245,255,${Math.max(0,0.9 - p)})`;
    ctx.shadowColor = 'rgba(255,255,220,0.45)';
    ctx.shadowBlur = 24;
    ctx.arc(moonX, moonY, moonRadius, 0, Math.PI*2);
    ctx.fill();
    ctx.shadowBlur = 0;
  }
  if(p > 0.15){
    const sunX = canvas.width*0.15;
    const sunY = canvas.height*0.22;
    const sunRad = 50;
    const sunAlpha = Math.max(0, (p-0.15)/(1-0.15));
    ctx.beginPath();
    ctx.fillStyle = `rgba(255,235,160,${sunAlpha})`;
    ctx.shadowColor = 'rgba(255,210,120,0.3)';
    ctx.shadowBlur = 40 * sunAlpha;
    ctx.arc(sunX, sunY, sunRad, 0, Math.PI*2);
    ctx.fill();
    ctx.shadowBlur = 0;
  }
}

function drawMountains(){
  if(IMGS.mountain){
    const offset = - (totalDistance * 0.15) % canvas.width;
    for(let x=offset-200; x<canvas.width+200; x+=IMGS.mountain.width){
      ctx.drawImage(IMGS.mountain, x, canvas.height*0.35, IMGS.mountain.width, IMGS.mountain.height*0.45);
    }
    return;
  }
  const p = dayProgress();
  for(let m=0;m<6;m++){
    const base = canvas.height*0.6 + Math.sin(m*1.4 + totalDistance/800)*20;
    const height = 120 + (m%2)*30;
    const x = (m*260 - (totalDistance*0.2)%600);
    ctx.beginPath();
    ctx.moveTo(x-200, canvas.height);
    ctx.lineTo(x+60, base-height);
    ctx.lineTo(x+160, canvas.height);
    const shade = Math.round(40*(1-p) + 120*p);
    ctx.fillStyle = `rgb(${shade},${shade},${shade+20})`;
    ctx.fill();
  }
}

function drawTerrain(){
  ctx.beginPath();
  ctx.moveTo(0, canvas.height);
  const viewLeft = totalDistance - bike.x;
  const step = 6;
  for(let sx=0; sx<=canvas.width+step; sx+=step){
    const worldX = Math.max(0, viewLeft + sx);
    const h = heightAt(worldX);
    ctx.lineTo(sx, h);
  }
  ctx.lineTo(canvas.width, canvas.height);
  ctx.closePath();
  const p = dayProgress();
  ctx.fillStyle = `rgb(${40*(1-p)+100*p|0}, ${30*(1-p)+110*p|0}, ${20*(1-p)+120*p|0})`;
  ctx.fill();

  const segStart = Math.floor(viewLeft / CONFIG.terrainSegW) - 2;
  const segEnd = Math.floor((viewLeft + canvas.width) / CONFIG.terrainSegW) + 4;
  for(let i=segStart;i<=segEnd;i++){
    const seg = terrain[i];
    if(!seg) continue;
    const segX = (i*CONFIG.terrainSegW) - viewLeft;
    if(seg.type === 'bump'){
      ctx.beginPath();
      const bw = CONFIG.terrainSegW;
      const top = seg.height - CONFIG.bumpHeight;
      ctx.moveTo(segX, seg.height);
      ctx.quadraticCurveTo(segX + bw/2, top - 6, segX + bw, seg.height);
      ctx.fillStyle = '#2a1f14';
      ctx.fill();
    } else if(seg.type === 'vado'){
      const bw = CONFIG.terrainSegW;
      const top = seg.height + CONFIG.vadoDepth;
      ctx.beginPath();
      ctx.moveTo(segX, seg.height);
      ctx.quadraticCurveTo(segX + bw/2, top + 6, segX + bw, seg.height);
      ctx.fillStyle = '#231b14';
      ctx.fill();
      ctx.fillStyle = 'rgba(20,60,120,0.25)';
      ctx.fillRect(segX + bw*0.18, seg.height + 2, bw*0.64, CONFIG.vadoDepth);
    } else if(seg.type === 'mountain'){
      ctx.beginPath();
      ctx.moveTo(segX, seg.height);
      ctx.lineTo(segX + CONFIG.terrainSegW/2, seg.height - 120);
      ctx.lineTo(segX + CONFIG.terrainSegW, seg.height);
      ctx.closePath();
      ctx.fillStyle = '#333';
      ctx.fill();
    }
  }
}

function drawBike(){
  const viewLeft = totalDistance - bike.x;
  const bikeX = bike.x;
  ctx.save();
  ctx.translate(bikeX, bike.y);
  ctx.rotate(bike.angle);

  if(IMGS.bike){
    const h = 56;
    const w = (IMGS.bike.width / IMGS.bike.height) * h;
    ctx.drawImage(IMGS.bike, -w/2, -h/2, w, h);
  } else {
    ctx.fillStyle = '#ef4444';
    ctx.fillRect(-28, -12, 56, 18);
    ctx.fillStyle = '#222';
    ctx.fillRect(-8, -28, 16, 20);
    ctx.beginPath();
    ctx.fillStyle = '#111';
    ctx.arc(-18, 6, CONFIG.wheelRadius, 0, Math.PI*2);
    ctx.arc(18, 6, CONFIG.wheelRadius, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = '#666';
    ctx.fillRect(-20,3,40,4);
  }
  ctx.restore();

  ctx.beginPath();
  const groundY = heightAt(totalDistance);
  ctx.ellipse(bikeX, groundY+8, 44, 10, 0, 0, Math.PI*2);
  ctx.fillStyle = 'rgba(0,0,0,0.35)';
  ctx.fill();
}

/* =================== FÍSICA y LÓGICA (rebote leve) =================== */
function updatePhysics(dt){
  const accel = keys.up || mobileTouch.accel;
  if(accel){
    bike.vx += CONFIG.accelPower * dt;
    if(AUD.sfx.accel && !muted){ try{ AUD.sfx.accel.currentTime = 0; AUD.sfx.accel.volume = 0.22; AUD.sfx.accel.play(); }catch(e){} }
  } else if(keys.right || mobileTouch.forward){
    bike.vx += 0.02 * dt;
  } else if(keys.left || mobileTouch.back){
    bike.vx -= 0.06 * dt;
  } else {
    bike.vx *= 0.995;
  }
  bike.vx = Math.max(-3, Math.min(CONFIG.maxSpeed, bike.vx));

  // gravedad y amortiguación ligera en aire para reducir "flotar"
  bike.vy += CONFIG.gravity * dt * 0.016;
  bike.vy *= 0.9985; // small air damping to reduce float

  // suspensión: posición objetivo del centro de la moto respecto al suelo
  const worldX = totalDistance;
  const groundY = heightAt(worldX);
  const suspensionRestY = groundY - CONFIG.suspensionRestOffset;

  // si la moto está por debajo del rest (penetra suelo) => corregir
  if(bike.y > suspensionRestY){
    // contacto firme: sitúa la moto exactamente en rest y anula vy pequeña
    bike.y = suspensionRestY;
    bike.vy = 0;
    bike.onGround = true;
  } else {
    bike.onGround = false;
    // si está por encima (en el aire) aplicamos fuerza de resorte hacia rest (suspensión)
    // esto hace que la moto vuelva rápido al suelo y limite la altura del salto
    const springForce = (suspensionRestY - bike.y) * CONFIG.suspensionStiffness;
    bike.vy += springForce * dt * 0.016;
    // aplicar amortiguación del resorte
    bike.vy *= CONFIG.suspensionDamping;
  }

  // mover verticalmente
  bike.y += bike.vy * dt * 0.6;

  // limitador superior de salto (no puede coger vy demasiado negativo)
  if(bike.vy < CONFIG.maxBounceVy){
    bike.vy = CONFIG.maxBounceVy;
  }

  // cálculo de ángulo basado en pendiente y ligera inclinación por vy
  const slope = (heightAt(worldX+20) - heightAt(worldX-20)) / 40;
  bike.angle = Math.atan2(-slope, 1) * 0.55 + bike.vy* -0.015;

  // Interacción con obstáculos (bump/vado) — ahora con impulso muy reducido
  const segIdx = Math.floor(worldX / CONFIG.terrainSegW);
  const seg = terrain[segIdx];
  if(seg){
    if(seg.type === 'bump'){
      // solo generar un pequeño empuje en vy si velocidad es alta y estaba en suelo
      if(bike.onGround && bike.vx > 3 && Math.random() < Math.min(0.06, bike.vx/80)){
        // impulso leve y controlado
        const impulse = -2.0 - Math.min(1.5, bike.vx * 0.08); // pequeño salto
        // reduce aún más por factor bumpBounceFactor
        bike.vy = Math.max(CONFIG.maxBounceVy, impulse * CONFIG.bumpBounceFactor);
        if(AUD.sfx.bump && !muted){ try{ AUD.sfx.bump.currentTime = 0; AUD.sfx.bump.play(); }catch(e){} }
      }
    } else if(seg.type === 'vado'){
      if(bike.onGround){
        bike.vx *= 0.987;
      } else {
        // al pasar en el aire por un vado, no aumentamos salto
        bike.vx *= 0.999;
      }
    }
  }

  // movimiento y puntuación
  const movement = Math.max(0, bike.vx) * dt;
  totalDistance += movement;
  score += Math.floor(movement*0.12);
  if(bike.vx < -0.8) score -= Math.floor(Math.abs(bike.vx)*0.2*dt);
  if(score < 0) score = 0;

  // progresión de nivel y música
  const newLevel = Math.min(CONFIG.levels, Math.floor(totalDistance / CONFIG.levelDistance) + 1);
  if(newLevel !== currentLevel){
    currentLevel = newLevel;
    setMusicForLevel(currentLevel);
    if(AUD.sfx.levelUp && !muted){ try{ AUD.sfx.levelUp.currentTime = 0; AUD.sfx.levelUp.play(); }catch(e){} }
  }

  ensureTerrainLength(totalDistance + canvas.width*1.2);
}

/* =================== HUD & GUARDADO =================== */
function drawHUD(){
  scoreEl.textContent = 'Puntaje: ' + Math.max(0, Math.floor(score));
  levelInfoEl.textContent = `Nivel: ${currentLevel} / ${CONFIG.levels} — Récord: ${bestScore}`;
  if(Math.floor(score) > bestScore){
    bestScore = Math.floor(score);
    localStorage.setItem(BEST_KEY, String(bestScore));
  }
}

/* =================== LOOP principal =================== */
function gameLoop(ts){
  if(!lastTs) lastTs = ts;
  const dt = Math.min(40, ts - lastTs) / 16.666;
  lastTs = ts;
  if(running){
    updatePhysics(dt);
    drawBackground();
    drawMountains();
    drawTerrain();
    drawBike();
    ctx.fillStyle = 'rgba(0,0,0,0.18)';
    ctx.fillRect(0,0,canvas.width,36);
    ctx.fillStyle = 'rgba(255,255,255,0.85)';
    ctx.font = '14px Inter, Arial';
    ctx.fillText('Distancia: ' + Math.floor(totalDistance) + ' px', 12, 22);
  } else {
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = '#fff';
    ctx.font = '28px Inter, Arial';
    ctx.fillText('Pausa — Presiona Pausa para continuar', 60, canvas.height/2);
  }
  drawHUD();
  requestAnimationFrame(gameLoop);
}
requestAnimationFrame(gameLoop);

/* =================== INPUTS (teclado, botones, touch) =================== */
window.addEventListener('keydown', (e)=>{
  if(e.key === 'ArrowRight' || e.key.toLowerCase() === 'd'){ keys.right = true; }
  if(e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a'){ keys.left = true; }
  if(e.key === 'ArrowUp' || e.key.toLowerCase() === 'w'){ keys.up = true; }
  if(e.key === ' '){ if(bike.onGround){ bike.vy = -3.2; bike.onGround=false; if(AUD.sfx.jump && !muted){ try{ AUD.sfx.jump.currentTime=0; AUD.sfx.jump.play(); }catch(e){} } } }
  if(e.key.toLowerCase() === 'p'){ togglePause(); }
});

window.addEventListener('keyup', (e)=>{
  if(e.key === 'ArrowRight' || e.key.toLowerCase() === 'd'){ keys.right = false; }
  if(e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a'){ keys.left = false; }
  if(e.key === 'ArrowUp' || e.key.toLowerCase() === 'w'){ keys.up = false; }
});

const btnBack = document.getElementById('btnBack');
const btnForward = document.getElementById('btnForward');
const btnAccel = document.getElementById('btnAccel');
const btnPause = document.getElementById('btnPause');
const btnMute = document.getElementById('btnMute');

btnBack.addEventListener('pointerdown', ()=>{ keys.left = true; });
btnBack.addEventListener('pointerup', ()=>{ keys.left = false; });
btnForward.addEventListener('pointerdown', ()=>{ keys.right = true; });
btnForward.addEventListener('pointerup', ()=>{ keys.right = false; });
btnAccel.addEventListener('pointerdown', ()=>{ keys.up = true; if(AUD.sfx.accel && !muted){ try{ AUD.sfx.accel.currentTime = 0; AUD.sfx.accel.play(); }catch(e){} } });
btnAccel.addEventListener('pointerup', ()=>{ keys.up = false; });

document.getElementById('mBack').addEventListener('pointerdown', ()=>{ mobileTouch.back=true; });
document.getElementById('mBack').addEventListener('pointerup', ()=>{ mobileTouch.back=false; });
document.getElementById('mForward').addEventListener('pointerdown', ()=>{ mobileTouch.forward=true; });
document.getElementById('mForward').addEventListener('pointerup', ()=>{ mobileTouch.forward=false; });
document.getElementById('mAccel').addEventListener('pointerdown', ()=>{ mobileTouch.accel=true; if(AUD.sfx.accel && !muted){ try{ AUD.sfx.accel.currentTime = 0; AUD.sfx.accel.play(); }catch(e){} } });
document.getElementById('mAccel').addEventListener('pointerup', ()=>{ mobileTouch.accel=false; });

btnPause.addEventListener('click', togglePause);
btnMute.addEventListener('click', ()=>{ muted = !muted; if(muted){ AUD.music && AUD.music.pause(); btnMute.textContent='Unmute'; } else { setMusicForLevel(currentLevel); btnMute.textContent='Mute'; } });

['pointercancel','pointerleave'].forEach(ev=>{
  document.getElementById('mAccel').addEventListener(ev, ()=>{ mobileTouch.accel=false; });
  document.getElementById('mBack').addEventListener(ev, ()=>{ mobileTouch.back=false; });
  document.getElementById('mForward').addEventListener(ev, ()=>{ mobileTouch.forward=false; });
});

function togglePause(){
  running = !running;
  if(running) lastTs = performance.now();
  else localStorage.setItem(BEST_KEY, String(bestScore));
}

/* =================== Responsive canvas scaling =================== */
function resizeCanvas(){
  const maxW = Math.min(window.innerWidth - 20, CONFIG.canvasW);
  const scale = maxW / CONFIG.canvasW;
  canvas.style.width = (CONFIG.canvasW * scale) + 'px';
  canvas.style.height = (CONFIG.canvasH * scale) + 'px';
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

/* =================== Reiniciar (opcional) =================== */
function restartGame(){
  score = 0;
  totalDistance = 0;
  bike.x = 220;
  bike.y = heightAt(0) - CONFIG.suspensionRestOffset;
  bike.vx = 0; bike.vy = 0;
  currentLevel = 1;
  setMusicForLevel(currentLevel);
}

/* =================== Notas al desarrollador ===================
 - Cambié la física para rebote leve:
   * Hay una "posición de reposo" (suspensionRestY) que es el punto donde la moto
     debería tocar el suelo. Si la moto está por encima, un resorte la atrae
     hacia esa posición con amortiguación configurables (suspensionStiffness/Damping).
   * Saltos por topes usan un impulso muy reducido (impulse ~ -2) y se limitan por maxBounceVy.
   * Fuerza de amortiguación en aire y cap sobre vy vertical hacen que la moto no "vuele".
 - Ajusta en CONFIG:
   * suspensionStiffness (aumenta->más pegada), suspensionDamping (0.6-0.95),
   * maxBounceVy (valor negativo; más cercano a 0 => saltos menos altos).
 - Reemplaza ASSETS.* con tus PNG/MP3. Si quieres, te puedo generar archivos de ejemplo
   (sprites y audios) y prepararte un ZIP con todo listo. Dime si quieres que lo haga.
================================================================== */

</script>
</body>
</html>
