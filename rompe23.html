<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Rompecabezas deslizante - Black Moon</title>
<style>
  :root{
    --gap: 6px;
    --bg: #0b0b0f;
    --panel: linear-gradient(180deg,#0f0f13,#08080a);
    --accent: #9b5cff;
  }
  *{box-sizing:border-box;font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;}
  body{
    margin:0;
    min-height:100vh;
    display:flex;
    align-items:center;
    justify-content:center;
    gap:24px;
    padding:24px;
    background: radial-gradient(1200px 600px at 10% 10%, rgba(155,92,255,0.06), transparent),
                radial-gradient(1000px 500px at 90% 90%, rgba(0,0,0,0.25), transparent),
                var(--bg);
    color:#e8e8ee;
  }
  .app{
    width:100%;
    max-width:980px;
    display:flex;
    gap:20px;
    align-items:flex-start;
  }

  /* Left: tablero */
  .board-wrap{
    flex:1;
    min-width:260px;
  }
  .board{
    background:var(--panel);
    border-radius:12px;
    padding:14px;
    display:flex;
    flex-direction:column;
    gap:12px;
    box-shadow: 0 6px 30px rgba(0,0,0,0.6), inset 0 1px rgba(255,255,255,0.02);
  }

  .puzzle{
    width:100%;
    aspect-ratio: 1 / 1;
    display:grid;
    gap:var(--gap);
    border-radius:10px;
    overflow:hidden;
    background: #111;
    touch-action: manipulation;
    position:relative;
  }

  .tile{
    background-size: 100% 100%;
    background-repeat: no-repeat;
    border-radius:8px;
    display:flex;
    align-items:center;
    justify-content:center;
    color:transparent;
    font-weight:700;
    user-select:none;
    cursor:pointer;
    transition: transform 160ms ease, box-shadow 160ms ease;
    box-shadow: 0 3px 8px rgba(0,0,0,0.45);
  }
  .tile:active{ transform: scale(.98); }
  .tile.blank{
    background: linear-gradient(180deg,#0b0b0f,#0b0b0f);
    box-shadow: none;
    cursor: default;
  }

  .controls{
    display:flex;
    gap:8px;
    align-items:center;
    flex-wrap:wrap;
  }
  .controls > *{font-size:14px}
  input[type="number"]{width:64px;padding:6px;border-radius:8px;border:1px solid #222;background:#0b0b0f;color:#e8e8e8}
  input[type="file"]{color:transparent}
  input[type="text"]{padding:6px;border-radius:8px;border:1px solid #222;background:#0b0b0f;color:#e8e8e8;min-width:160px}
  button{
    background:linear-gradient(180deg,var(--accent), #6e2bff);
    border:none;padding:8px 12px;border-radius:8px;color:white;cursor:pointer;
  }
  .meta{
    display:flex;
    gap:12px;
    justify-content:space-between;
    align-items:center;
    margin-top:6px;
    font-size:13px;
    color:#cfcfe3;
  }
  .small{font-size:12px;color:#aeb0c6}

  /* derecha: info */
  .side{
    width:300px;
    max-width:40%;
    min-width:220px;
    display:flex;
    flex-direction:column;
    gap:12px;
  }
  .card{
    background:linear-gradient(180deg,#0d0d11,#071);
    border-radius:12px;padding:12px;color:#eaeaff;background:linear-gradient(180deg,#0f0f13,#08080a);
    box-shadow:0 6px 20px rgba(0,0,0,0.5);
  }
  .hint{font-size:13px;color:#cfcfe3}
  .win {
    padding:12px;border-radius:10px;background:linear-gradient(90deg,#1b1b2b,#0b1326);
    border:1px solid rgba(155,92,255,0.15);color:#e8e8ff;text-align:center;
  }
  @media (max-width:840px){
    .app{flex-direction:column;align-items:center}
    .side{width:100%}
  }
</style>
</head>
<body>
  <div class="app">
    <div class="board-wrap">
      <div class="board">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div>
            <strong>Rompecabezas deslizante</strong>
            <div class="small">Haz clic en una pieza adyacente al hueco para moverla.</div>
          </div>
          <div class="small">Black Moon ‚Ä¢ Puzzle</div>
        </div>

        <div id="puzzle" class="puzzle" aria-label="Tablero del rompecabezas"></div>

        <div class="controls">
  <label class="small">Tama√±o:
    <input id="gridSize" type="number" min="2" max="8" value="3">
  </label>

  <label class="small">Imagen (10 opciones):
    <select id="imgSelect">
      <option value="">-- Ninguna --</option>
      <option value="https://picsum.photos/500?random=1">Imagen 1</option>
      <option value="https://picsum.photos/500?random=2">Imagen 2</option>
      <option value="https://picsum.photos/500?random=3">Imagen 3</option>
      <option value="https://picsum.photos/500?random=4">Imagen 4</option>
      <option value="https://picsum.photos/500?random=5">Imagen 5</option>
      <option value="https://picsum.photos/500?random=6">Imagen 6</option>
      <option value="https://picsum.photos/500?random=7">Imagen 7</option>
      <option value="https://picsum.photos/500?random=8">Imagen 8</option>
      <option value="https://picsum.photos/500?random=9">Imagen 9</option>
      <option value="https://picsum.photos/500?random=10">Imagen 10</option>
    </select>
  </label>

  <button id="shuffleBtn">Mezclar</button>
  <button id="resetBtn">Reiniciar</button>
</div>

        <div class="meta">
          <div>Movimientos: <span id="moves">0</span></div>
          <div>Tiempo: <span id="time">00:00</span></div>
        </div>

        <div id="message" class="small"></div>
      </div>
    </div>

    <div class="side">
      <div class="card">
        <strong>Instrucciones</strong>
        <p class="hint">1) Elige tama√±o (3 = 3√ó3). 2) Pon una imagen (URL o subir). 3) Mezcla y resuelve. El shuffle se hace con movimientos legales para asegurar que el rompecabezas sea solucionable.</p>
      </div>

      <div class="card">
        <strong>Consejos</strong>
        <ul class="small">
          <li>Para m√°s reto, aumenta el tama√±o a 4√ó4 o 5√ó5.</li>
          <li>Usa im√°genes con contrastes y formas claras para identificar piezas m√°s f√°cil.</li>
        </ul>
      </div>

      <div id="winBox" class="card win" style="display:none">
        <strong>¬°Felicidades! ‚Äî Rompecabezas resuelto üéâ</strong>
        <div class="small" id="finalStats"></div>
      </div>
    </div>
  </div>

<script>
(() => {
  const puzzleEl = document.getElementById('puzzle');
  const gridInput = document.getElementById('gridSize');
  const shuffleBtn = document.getElementById('shuffleBtn');
  const resetBtn = document.getElementById('resetBtn');
  const imgUrlInput = document.getElementById('imgUrl');
  const imgFileInput = document.getElementById('imgFile');
  const applyImgBtn = document.getElementById('applyImg');
  const movesEl = document.getElementById('moves');
  const timeEl = document.getElementById('time');
  const messageEl = document.getElementById('message');
  const winBox = document.getElementById('winBox');
  const finalStats = document.getElementById('finalStats');

  let gridSize = parseInt(gridInput.value,10) || 3;
  let imageSrc = null; // url or dataURL
  let tiles = []; // array of objects {index: correctIndex, pos: currentPos, el}
  let blankPos = null;
  let moves = 0;
  let timer = null;
  let seconds = 0;
  let isShuffling = false;

  function startTimer(){
    clearInterval(timer);
    seconds = 0;
    timeEl.textContent = formatTime(seconds);
    timer = setInterval(()=> {
      seconds++;
      timeEl.textContent = formatTime(seconds);
    },1000);
  }
  function stopTimer(){ clearInterval(timer); timer = null; }

  function formatTime(s){
    const mm = String(Math.floor(s/60)).padStart(2,'0');
    const ss = String(s%60).padStart(2,'0');
    return `${mm}:${ss}`;
  }

  function setGridSize(n){
    gridSize = n;
    puzzleEl.style.gridTemplateColumns = `repeat(${n}, 1fr)`;
    puzzleEl.style.gridTemplateRows = `repeat(${n}, 1fr)`;
    createTiles();
  }

  function createTiles(){
    // reset
    puzzleEl.innerHTML = '';
    tiles = [];
    moves = 0;
    movesEl.textContent = moves;
    messageEl.textContent = '';
    winBox.style.display = 'none';
    stopTimer();

    const total = gridSize * gridSize;
    for(let i=0;i<total;i++){
      const tile = document.createElement('div');
      tile.className = 'tile';
      tile.dataset.correct = i; // correct position index
      tile.dataset.pos = i;     // current position index initially same
      tile.textContent = i+1;
      tile.addEventListener('click', onTileClick);
      tiles.push({index:i, pos:i, el:tile});
      puzzleEl.appendChild(tile);
    }
    // mark last tile as blank
    blankPos = total - 1;
    tiles[blankPos].el.classList.add('blank');
    tiles[blankPos].el.textContent = '';
    applyBackgroundImage();
  }

  function applyBackgroundImage(){
    // apply background image to tiles if imageSrc exists
    const total = gridSize*gridSize;
    if(!imageSrc){
      // plain colored tiles
      tiles.forEach(t=>{
        t.el.style.backgroundImage = '';
        t.el.style.backgroundColor = '#14141a';
        t.el.style.color = '#bdbde6';
        t.el.style.display = 'flex';
        t.el.style.justifyContent = 'center';
      });
      return;
    }

    // use background-position for each tile according to its correct index
    const n = gridSize;
    tiles.forEach(t=>{
      const correctIdx = t.index;
      const row = Math.floor(correctIdx / n);
      const col = correctIdx % n;
      // each tile's background-size must be (n * 100)% to allow positioning by percent
      t.el.style.backgroundImage = `url("${imageSrc}")`;
      t.el.style.backgroundSize = `${n * 100}% ${n * 100}%`;
      const x = (col / (n - 1)) * 100;
      const y = (row / (n - 1)) * 100;
      // use background-position but clamp for n=1 edgecase
      t.el.style.backgroundPosition = `${x}% ${y}%`;
      t.el.style.color = 'transparent';
      t.el.style.backgroundClip = 'border-box';
    });
    // blank tile: make dark
    tiles[blankPos].el.classList.add('blank');
    tiles[blankPos].el.style.backgroundImage = '';
    tiles[blankPos].el.style.backgroundColor = '#0b0b0f';
    tiles[blankPos].el.textContent = '';
  }

  function onTileClick(e){
    if(isShuffling) return;
    const clickedEl = e.currentTarget;
    const clickedPos = parseInt(clickedEl.dataset.pos,10);
    if(canMove(clickedPos)){
      move(clickedPos);
      if(moves === 1 && !timer) startTimer();
      moves++;
      movesEl.textContent = moves;
      if(checkSolved()){
        stopTimer();
        showWin();
      }
    }
  }

  function canMove(pos){
    const n = gridSize;
    const r1 = Math.floor(pos / n), c1 = pos % n;
    const r2 = Math.floor(blankPos / n), c2 = blankPos % n;
    const dist = Math.abs(r1 - r2) + Math.abs(c1 - c2);
    return dist === 1;
  }

  function move(pos){
    // swap tile at pos with blankPos
    const tileA = tiles.find(t=>t.pos === pos);
    const tileB = tiles.find(t=>t.pos === blankPos);
    if(!tileA || !tileB) return;
    // swap dataset pos and visual order
    tileA.el.dataset.pos = blankPos;
    tileB.el.dataset.pos = pos;
    // update tile objects
    const tmp = tileA.pos;
    tileA.pos = tileB.pos;
    tileB.pos = tmp;
    // re-append in DOM to reflect positions visually (grid auto-places by order)
    // We'll order tiles in DOM by current pos to keep it simple:
    const ordered = tiles.slice().sort((a,b)=>a.pos - b.pos);
    puzzleEl.innerHTML = '';
    ordered.forEach(t => puzzleEl.appendChild(t.el));
    // update blankPos
    blankPos = pos;
  }

  function shuffle(steps = 200){
    isShuffling = true;
    // perform random legal moves from solved state to guarantee solvable
    let last = -1;
    const n = gridSize;
    for(let i=0;i<steps;i++){
      const neighbors = [];
      const r = Math.floor(blankPos / n), c = blankPos % n;
      const candidates = [
        {r:r-1,c}, {r:r+1,c}, {r,c:c-1}, {r,c:c+1}
      ];
      for(const cand of candidates){
        if(cand.r >= 0 && cand.r < n && cand.c >= 0 && cand.c < n){
          const pos = cand.r * n + cand.c;
          if(pos !== last) neighbors.push(pos);
        }
      }
      const pick = neighbors[Math.floor(Math.random() * neighbors.length)];
      // move picked tile into blank
      move(pick); last = blankPos; // note: after move blankPos becomes pick's old pos
    }
    // reset counters
    moves = 0;
    movesEl.textContent = moves;
    seconds = 0;
    timeEl.textContent = formatTime(seconds);
    stopTimer();
    isShuffling = false;
  }

  function checkSolved(){
    // solved if each tile's pos === index except blank allowed at last
    for(const t of tiles){
      if(t.pos !== t.index) return false;
    }
    return true;
  }

  function showWin(){
    messageEl.textContent = '¬°Resuelto!';
    winBox.style.display = 'block';
    finalStats.textContent = `Movimientos: ${moves} ‚Ä¢ Tiempo: ${formatTime(seconds)}`;
  }

  function applyImageFromUrl(url){
    if(!url) { imageSrc = null; applyBackgroundImage(); return; }
    // simple validation: try to load image
    const img = new Image();
    img.onload = () => {
      imageSrc = url;
      applyBackgroundImage();
    };
    img.onerror = () => {
      messageEl.textContent = 'No se pudo cargar la imagen desde la URL.';
      setTimeout(()=> messageEl.textContent = '', 3000);
    };
    img.src = url;
  }

  function applyImageFromFile(file){
    if(!file) return;
    const reader = new FileReader();
    reader.onload = (ev) => {
      imageSrc = ev.target.result;
      applyBackgroundImage();
    };
    reader.readAsDataURL(file);
  }

  // Event listeners
  gridInput.addEventListener('change', ()=> {
    const n = Math.max(2, Math.min(8, parseInt(gridInput.value,10) || 3));
    gridInput.value = n;
    setGridSize(n);
  });

  applyImgBtn.addEventListener('click', ()=> {
    const url = imgUrlInput.value.trim();
    if(imgFileInput.files && imgFileInput.files[0]) {
      applyImageFromFile(imgFileInput.files[0]);
    } else if(url) {
      applyImageFromUrl(url);
    } else {
      imageSrc = null;
      applyBackgroundImage();
    }
  });

  shuffleBtn.addEventListener('click', ()=> {
    shuffle(Math.max(100, gridSize*gridSize*40)); // more steps for larger boards
  });

  resetBtn.addEventListener('click', ()=> {
    createTiles();
  });

  // keyboard arrows to move (optional)
  document.addEventListener('keydown', (e)=>{
    if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].indexOf(e.key) === -1) return;
    // find tile adjacent in direction and move it into blank
    const n = gridSize;
    const br = Math.floor(blankPos/n), bc = blankPos % n;
    let targetPos = null;
    if(e.key === 'ArrowUp' && br < n-1) targetPos = (br+1)*n + bc; // tile below blank moves up
    if(e.key === 'ArrowDown' && br > 0) targetPos = (br-1)*n + bc;
    if(e.key === 'ArrowLeft' && bc < n-1) targetPos = br*n + (bc+1);
    if(e.key === 'ArrowRight' && bc > 0) targetPos = br*n + (bc-1);
    if(targetPos !== null && !isShuffling){
      move(targetPos);
      moves++; movesEl.textContent = moves;
      if(moves === 1 && !timer) startTimer();
      if(checkSolved()){ stopTimer(); showWin(); }
    }
  });

  // init
  setGridSize(gridSize);

  // small helper: if user drops an image onto board, use it
  puzzleEl.addEventListener('dragover', (ev)=> ev.preventDefault());
  puzzleEl.addEventListener('drop', (ev)=>{
    ev.preventDefault();
    const f = ev.dataTransfer.files && ev.dataTransfer.files[0];
    if(f && f.type.startsWith('image/')) applyImageFromFile(f);
  });

})();
</script>
</body>
</html>
